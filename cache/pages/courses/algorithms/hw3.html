<h1><strong>Due Date</strong>: Feb 18, before midnight (11:59:59PM)</h1>
<p>This assignment comprises both written questions and
implementation-based lab.</p>
<hr>
<h1>HW3</h1>
<p>Answer the following questions from the DPV book i) Q1.17, ii) Q1.19,
iii) Q 1.23, and iv) given that $x^{86} \equiv 6 \mod 29$, find $x$.</p>
<h1>Lab3: Primality Testing</h1>
<p>You will compare the two randomized primality testing algorithms -- the
basic one in Fig 1.8, and the Miller-Rabin algorithm.
Both these methods require modular exponentiation, so you <strong>must</strong> also
implement the <em>modexp</em> algorithm in Fig 1.4.</p>
<p>Implement the randomized primality algorithm in Fig 1.8 in the book. </p>
<p>Next, implement the Miller-Rabin primality test, which is informally
described in the gray box just before sec 1.3.1 in the book, and whose pseudo-code is
given below:</p>
<pre class="code literal-block"><span class="n">MillerRabin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="n">Pick</span> <span class="n">positive</span> <span class="n">intgers</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">aK</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="n">at</span> <span class="n">random</span>
    <span class="n">Find</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">such</span> <span class="n">that</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="mi">2</span><span class="o">^</span><span class="n">t</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">K</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">ai</span><span class="o">^</span><span class="n">u</span> <span class="n">mod</span> <span class="n">N</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">mod</span> <span class="n">N</span> 
            <span class="n">mark</span> <span class="n">that</span> <span class="n">ai</span> <span class="n">passes</span> <span class="n">the</span> <span class="n">test</span>
        <span class="k">else</span>
            <span class="c1"># repeated squaring, keep track of previous value of z,</span>
            <span class="c1"># find first occurrence of 1 if any</span>
            <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">..</span><span class="p">,</span> <span class="n">t</span>
                <span class="n">compute</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span> <span class="n">mod</span> <span class="n">N</span>
                <span class="c1"># ai passes the test iff squared value is 1 and prev value is N-1</span>
                <span class="c1"># else ai fails the test</span>
            <span class="c1">#ai also fails the test if no 1 is encountered above</span>
    <span class="k">if</span> <span class="nb">all</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">aK</span> <span class="k">pass</span> <span class="n">the</span> <span class="n">test</span>
        <span class="k">return</span> <span class="n">yes</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">no</span>
</pre>

<h3>Carmichael numbers</h3>
<p>Test your code on the following Carmichael numbers:</p>
<pre class="code literal-block"><span class="n">Carmichael</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mi">561</span><span class="p">,</span>
    <span class="mi">6601</span><span class="p">,</span>
    <span class="mi">67902031</span><span class="p">,</span>
    <span class="mi">8956911601</span><span class="p">,</span>
    <span class="mi">438253965870337</span><span class="p">,</span>
    <span class="mi">999987515379253441</span><span class="p">,</span>
    <span class="mi">1745094470986967126132341</span><span class="p">,</span>
    <span class="mi">844154128953833755776750022681</span><span class="p">,</span>
    <span class="mi">365376903642671522645639268043801</span><span class="p">,</span>
    <span class="mi">1334733877147062382486934807105197899496002201113849920496510541601</span><span class="p">,</span>
    <span class="mi">2887148238050771212671429597130393991977609459279722700926516024197432303799152733116328983144639225941977803110929349655578418949441740933805615113979999421542416933972905423711002751042080134966731755152859226962916775325475044445856101949404200039904432116776619949629539250452698719329070373564032273701278453899126120309244841494728976885406024976768122077071687938121709811322297802059565867</span>
<span class="p">]</span>
</pre>

<p>Except for 561, these numbers are difficult for the basic primality
testing code, but will be marked as non-prime by MillerRabin for
reasonable values of $K$. On the contrary, some numbers like
999987515379253441 are still incorrectly marked as prime by the basic
test, even for $K=1000$!</p>
<p>Your script should test all of the numbers above, except for the last
one, which will cause "maximum recursion exceed" error for
the recursive version of <em>modexp</em>. Your script should print whether the
given Carmichael number is prime or not, and it must also print 
the fraction of choices of $a_i$ (out of the $K$)
that pass Fermat's test for each method. Try different value of $K$,
such as $K=10, 20, 50, 100, 1000$.</p>
<p><strong>Bonus:</strong> To run the last number in the list above you'll have to
implement a non-recursive version of <em>modexp</em>, which will earn bonus
points.</p>
<hr>
<h2>Grading</h2>
<p>Use submitty to submit exactly one PDF and one .py script. 
The .py script must be implemented in Python3. 
You can hand write your solutions to the HW, take
pics, or you can type up your answers and convert to PDF.</p>
<p>The PDF file must contain your solutions to the HW, and the output from
the python script. The script output should be whether each Carmichael
number is prime or not, and the fraction of choices of $a_i$ that pass
the test (even if the number is eventually identified as non-prime).</p>
<hr>
<h2>Policy on Academic Honesty</h2>
<p>You are free to discuss how to tackle the assignment, but all coding
must be your own. Please do not copy or modify code from anyone else,
including code on the web. Any students caught violating the academic
honesty principle will get an automatic F grade on the course and will
be referred to the dean of students for disciplinary action.</p>